\chapter{Teste Aspirador -\/ Parte 2/2}
\hypertarget{teste_aspirador2}{}\label{teste_aspirador2}\index{Teste Aspirador -\/ Parte 2/2@{Teste Aspirador -\/ Parte 2/2}}
\texorpdfstring{$\vert$}{|} \href{teste_tvector.html}{\texttt{ Teste\+TVector}} \texorpdfstring{$\vert$}{|} \href{teste_aspirador1.html}{\texttt{ Aspirador 1}} \texorpdfstring{$\vert$}{|} \href{teste_aspirador2.html}{\texttt{ Aspirador 2}} \texorpdfstring{$\vert$}{|} \href{teste_puzzle8.html}{\texttt{ Puzzle 8}} \texorpdfstring{$\vert$}{|} \href{teste_8damas.html}{\texttt{ 8 Damas}} \texorpdfstring{$\vert$}{|} \href{teste_particao.html}{\texttt{ Partição}} \texorpdfstring{$\vert$}{|} \href{teste_artificial.html}{\texttt{ Artificial}} \texorpdfstring{$\vert$}{|}

Execução de exemplo com base no problema do Aspirador. Selecione o projeto \doxylink{classTProcuraConstrutiva}{TProcura\+Construtiva}, e execute. Pode acompanhar o teste excutando as ações localmente.\hypertarget{teste_aspirador2_autotoc_md34}{}\doxysubsection{\texorpdfstring{Sumário}{Sumário}}\label{teste_aspirador2_autotoc_md34}

\begin{DoxyItemize}
\item \doxylink{teste_aspirador2_aspirador-a10}{Ação 10 -\/ Procura em Profundidade}
\item \doxylink{teste_aspirador2_aspirador-a11}{Ação 11 -\/ Efetuar uma procura em Profundidade Primeiro}
\item \doxylink{teste_aspirador2_aspirador-a12}{Ação 12 -\/ Ver uma árvore de procura maior}
\item \doxylink{teste_aspirador2_aspirador-a13}{Ação 13 -\/ Profundidade Iterativa}
\item \doxylink{teste_aspirador2_aspirador-a14}{Ação 14 -\/ Profundidade ilimitada}
\item \doxylink{teste_aspirador2_aspirador-a15}{Ação 15 -\/ Desafio Procura Profundidade}
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{Teste\ TProcurasConstrutivas}
\DoxyCodeLine{Problema:}
\DoxyCodeLine{\ \ 1\ -\/\ Aspirador}
\DoxyCodeLine{\ \ 2\ -\/\ Puzzle\ 8}
\DoxyCodeLine{\ \ 3\ -\/\ 8\ Damas}
\DoxyCodeLine{\ \ 4\ -\/\ Partição}
\DoxyCodeLine{\ \ 5\ -\/\ Artificial}
\DoxyCodeLine{Opção:\ 1}

\end{DoxyCode}


Selecione o problema do Aspirador\+: {\bfseries{1.}}

\label{teste_aspirador2_aspirador-a10}%
\Hypertarget{teste_aspirador2_aspirador-a10}%
\hypertarget{teste_aspirador2_autotoc_md35}{}\doxysubsection{\texorpdfstring{Ação 10 -\/ Procura em Profundidade}{Ação 10 - Procura em Profundidade}}\label{teste_aspirador2_autotoc_md35}
 
\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{aspirador_profundidade.png}
\doxyfigcaption{Profundidade Primeiro -\/ expande primeiro os estados mais profundos}
\end{DoxyImage}
   

Avançamos agora para a procura em profundidade. Neste caso temos neste algoritmo diversas estratégias. Podemos executar esta procura com um limite de profundidade. Vamos fazer isso na instância 2, que sabemos ter uma solução de 3 movimentos.

\label{teste_aspirador2_aspirador-a11}%
\Hypertarget{teste_aspirador2_aspirador-a11}%
\hypertarget{teste_aspirador2_autotoc_md36}{}\doxysubsection{\texorpdfstring{Ação 11 -\/ Efetuar uma procura em Profundidade Primeiro}{Ação 11 - Efetuar uma procura em Profundidade Primeiro}}\label{teste_aspirador2_autotoc_md36}
Utilizar a instância número 2, o algoritmo profundidade primeiro, com limite de profundidade a 3, com nível de debug máximo, ignorando repetidos e ver ações a 1\+: {\bfseries{1; 2; 3; 1; 3; 7; 3; 2; 4; 8; 1; 6; 1; {\itshape ENTER}; 6.}}

O parâmetro 1 é o algoritmo, em que o 3 é a profundidade primeiro.


\begin{DoxyCode}{0}
\DoxyCodeLine{Algoritmo\ base\ a\ executar.}
\DoxyCodeLine{1:\ Largura\ Primeiro}
\DoxyCodeLine{2:\ Custo\ Uniforme}
\DoxyCodeLine{3:\ Profundidade\ Primeiro}
\DoxyCodeLine{4:\ Melhor\ Primeiro}
\DoxyCodeLine{5:\ A*}
\DoxyCodeLine{6:\ IDA*}
\DoxyCodeLine{7:\ Branch\ and\ Bound}
\DoxyCodeLine{Algoritmo\ (atual\ 1):}

\end{DoxyCode}


O parâmetro 7 é o limite, com diferentes interpretações conforme o algoritmo. ~\newline
 Na procura em largura o limite servia para limitar o número de estados gerados mas não expandidos. Aqui serve para limitar o nível de profundidade, que é fixado a 3.


\begin{DoxyCode}{0}
\DoxyCodeLine{Opção:\ 6}
\DoxyCodeLine{g:0}
\DoxyCodeLine{\ *\ [*]}
\DoxyCodeLine{\ \ +g:1\ 1|2\ esq}
\DoxyCodeLine{\ \ |[*]\ *}
\DoxyCodeLine{\ \ |\ \ +g:2\ 2|4\ dir}
\DoxyCodeLine{\ \ |\ \ |\ *\ [*]}
\DoxyCodeLine{\ \ |\ \ |}
\DoxyCodeLine{\ \ |\ \ +g:2\ 2|4\ asp}
\DoxyCodeLine{\ \ |\ \ \ [.]\ *}
\DoxyCodeLine{\ \ |}
\DoxyCodeLine{\ \ +g:1\ 2|4\ asp}
\DoxyCodeLine{\ \ \ \ *\ [.]}
\DoxyCodeLine{\ \ \ \ \ +g:2\ 3|6\ esq}
\DoxyCodeLine{\ \ \ \ \ |[*]\ .}
\DoxyCodeLine{\ \ \ \ \ |}
\DoxyCodeLine{\ \ \ \ \ +g:2\ 3|6\ asp}
\DoxyCodeLine{\ \ \ \ \ \ \ *\ [.]}
\DoxyCodeLine{}
\DoxyCodeLine{\ P1=3\ P2=4\ P3=1\ P4=10\ P5=0\ P6=1\ P7=3\ P8=1\ P9=100\ P10=0}
\DoxyCodeLine{\ P11=0}
\DoxyCodeLine{Aspirador}
\DoxyCodeLine{\ P1(Algoritmo):\ Profundidade\ Primeiro\ |\ P2(Debug):\ completo\ |\ P3(Seed):\ 1\ |\ P4(Tempo):\ 10\ |\ P5(Iterações):\ 0}
\DoxyCodeLine{\ P6(Ver):\ 1\ |\ P7(Limite):\ 3\ |\ P8(Repetidos):\ ignorar\ |\ P9(pesoAStar):\ 100\ |\ P10(ruido):\ 0}
\DoxyCodeLine{\ P11(baralhar):\ 0}
\DoxyCodeLine{\ *\ [*]}
\DoxyCodeLine{I1(Custo):\ -\/1\ |\ I2(Tempo(ms)):\ 12\ |\ I3(Iterações):\ 0\ |\ I4(Expansões):\ 3\ |\ I5(Gerações):\ 6\ |}
\DoxyCodeLine{I6(Lower\ Bound):\ 0}
\DoxyCodeLine{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_}
\DoxyCodeLine{|\ 1\ -\/\ Inicializar\ |\ 2\ -\/\ Explorar\ |\ 3\ -\/\ Parâmetros\ \ \ \ |\ 4\ -\/\ Solução\ |}
\DoxyCodeLine{|\ 5\ -\/\ Indicadores\ |\ 6\ -\/\ Executar\ |\ 7\ -\/\ Configurações\ |\ 8\ -\/\ Teste\ \ \ |}

\end{DoxyCode}


Podemos ver todos os estados gerados. A árvore tendo 3 níveis, permite dois movimentos, pelo que não foi descoberta a solução, retornando -\/1. Embora o indicador 6 não seja atualizado, este resultado pode ser utilizado para saber que não há nenhuma solução de comprimento inferior a 3, ou seja, é um lower bound, neste caso 3, já que o custo de cada movimento é unitário.

Esta visualização da árvore da procura é interessante para pequenos problemas, mas naturalmente que procuras maiores torna-\/se impraticável. Podemos observar aqui que o estado inicial foi gerado novamente, dado que estamos a ignorar os repetidos.

\label{teste_aspirador2_aspirador-a12}%
\Hypertarget{teste_aspirador2_aspirador-a12}%
\hypertarget{teste_aspirador2_autotoc_md37}{}\doxysubsection{\texorpdfstring{Ação 12 -\/ Ver uma árvore de procura maior}{Ação 12 - Ver uma árvore de procura maior}}\label{teste_aspirador2_autotoc_md37}
Colocar a profundidade a 10, e o nível de debug a 3\+: {\bfseries{1; 2; 3; 7; 10; 2; 3; {\itshape ENTER}; 6.}}


\begin{DoxyCode}{0}
\DoxyCodeLine{Opção:\ 6}
\DoxyCodeLine{-\/-\/+-\/-\/+-\/-\/+-\/-\/+-\/-\/+-\/-\/+-\/-\/+-\/-\/+-\/-\/+=\ g:9\ 9|18}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |[*]\ *}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ +=\ g:9\ 9|18}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ \ \ *\ [.]}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ +-\/-\/+=\ g:9\ 10|20}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ \ \ \ |\ .\ [*]}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ \ \ \ +=\ g:9\ 10|20}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ \ \ \ \ [.]\ *}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ +-\/-\/+-\/-\/+=\ g:9\ 12|24}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ \ \ \ |\ \ |\ *\ [.]}
\DoxyCodeLine{\ \ |\ \ |\ \ |\ \ |\ \ |\ \ |\ \ \ \ \ |\ \ +\ Solução\ encontrada!}
\DoxyCodeLine{[.]\ .\ (g:9)}
\DoxyCodeLine{\ P1=3\ P2=3\ P3=1\ P4=10\ P5=0\ P6=1\ P7=10\ P8=1\ P9=100\ P10=0}
\DoxyCodeLine{\ P11=0}
\DoxyCodeLine{Aspirador}
\DoxyCodeLine{\ P1(Algoritmo):\ Profundidade\ Primeiro\ |\ P2(Debug):\ detalhe\ |\ P3(Seed):\ 1\ |\ P4(Tempo):\ 10\ |\ P5(Iterações):\ 0}
\DoxyCodeLine{\ P6(Ver):\ 1\ |\ P7(Limite):\ 10\ |\ P8(Repetidos):\ ignorar\ |\ P9(pesoAStar):\ 100\ |\ P10(ruido):\ 0}
\DoxyCodeLine{\ P11(baralhar):\ 0}
\DoxyCodeLine{[.]\ .}
\DoxyCodeLine{I1(Custo):\ 9\ |\ I2(Tempo(ms)):\ 22\ |\ I3(Iterações):\ 0\ |\ I4(Expansões):\ 12\ |\ I5(Gerações):\ 24\ |}
\DoxyCodeLine{I6(Lower\ Bound):\ 0}
\DoxyCodeLine{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_}

\end{DoxyCode}
 Com o nível debug a 3 vemos a árvore de procura apenas os estados folha, mas não os estados expandidos. A informação é mais reduzida, mas poderá ser uma boa forma de analisar os estados em que o algoritmo volta para trás, já que podem ter alguma característica relevante, ainda não implementada. A solução não é óptima, tem comprimento 9! Podemos visualizar a solução, introduza\+: {\bfseries{4.}}


\begin{DoxyCode}{0}
\DoxyCodeLine{Opção:\ 4}
\DoxyCodeLine{}
\DoxyCodeLine{\ *\ [*]\ (g:0)}
\DoxyCodeLine{[*]\ *\ \ (g:1)}
\DoxyCodeLine{\ *\ [*]\ (g:2)}
\DoxyCodeLine{[*]\ *\ \ (g:3)}
\DoxyCodeLine{\ *\ [*]\ (g:4)}
\DoxyCodeLine{[*]\ *\ \ (g:5)}
\DoxyCodeLine{\ *\ [*]\ (g:6)}
\DoxyCodeLine{\ *\ [.]\ (g:7)}
\DoxyCodeLine{[*]\ .\ \ (g:8)}
\DoxyCodeLine{[.]\ .\ \ (g:9)}

\end{DoxyCode}


Como o algoritmo é cego, segue a ordem dos sucessores. Neste caso está sempre a trocar de posição antes de aspirar. Apenas foi ver as alternativas quando teve de voltar para trás, devido ao limite de profundidade. Se tivéssemos escolhido uma profundidade menor, a solução obtida seria também menor. Mas se a profundidade fosse menor que a solução mais curta, não iriamos obter nenhuma solução. É com base nesse dilema que surge a procura em profundidade iterativa, no caso deste código é executada com o limite=0.

\label{teste_aspirador2_aspirador-a13}%
\Hypertarget{teste_aspirador2_aspirador-a13}%
\hypertarget{teste_aspirador2_autotoc_md38}{}\doxysubsection{\texorpdfstring{Ação 13 -\/ Profundidade Iterativa}{Ação 13 - Profundidade Iterativa}}\label{teste_aspirador2_autotoc_md38}
Colocar a profundidade iterativa (limite a 0), e o nível de debug a 2\+: {\bfseries{1; 2; 3; 7; 0; 2; 2; {\itshape ENTER}; 6.}}


\begin{DoxyCode}{0}
\DoxyCodeLine{Iteração\ 1:}
\DoxyCodeLine{=\ g:0}
\DoxyCodeLine{Iteração\ 2:}
\DoxyCodeLine{-\/-\/+=\ g:1\ 1|2}
\DoxyCodeLine{\ \ +=\ g:1\ 1|2}
\DoxyCodeLine{Iteração\ 3:}
\DoxyCodeLine{-\/-\/+-\/-\/+=\ g:2\ 3|6}
\DoxyCodeLine{\ \ |\ \ +=\ g:2\ 3|6}
\DoxyCodeLine{\ \ +-\/-\/+=\ g:2\ 4|8}
\DoxyCodeLine{\ \ \ \ \ +=\ g:2\ 4|8}
\DoxyCodeLine{Iteração\ 4:}
\DoxyCodeLine{-\/-\/+-\/-\/+-\/-\/+=\ g:3\ 7|14}
\DoxyCodeLine{\ \ |\ \ |\ \ +=\ g:3\ 7|14}
\DoxyCodeLine{\ \ |\ \ +-\/-\/+=\ g:3\ 8|16}
\DoxyCodeLine{\ \ |\ \ \ \ \ +=\ g:3\ 8|16}
\DoxyCodeLine{\ \ +-\/-\/+-\/-\/+=\ g:3\ 10|20}
\DoxyCodeLine{\ \ \ \ \ |\ \ +\ Solução\ encontrada!}
\DoxyCodeLine{[.]\ .\ (g:3)}
\DoxyCodeLine{\ P1=3\ P2=2\ P3=1\ P4=10\ P5=0\ P6=1\ P7=0\ P8=1\ P9=100\ P10=0}
\DoxyCodeLine{\ P11=0}
\DoxyCodeLine{Aspirador}
\DoxyCodeLine{\ P1(Algoritmo):\ Profundidade\ Primeiro\ |\ P2(Debug):\ passos\ |\ P3(Seed):\ 1\ |\ P4(Tempo):\ 10\ |\ P5(Iterações):\ 0}
\DoxyCodeLine{\ P6(Ver):\ 1\ |\ P7(Limite):\ 0\ |\ P8(Repetidos):\ ignorar\ |\ P9(pesoAStar):\ 100\ |\ P10(ruido):\ 0}
\DoxyCodeLine{\ P11(baralhar):\ 0}
\DoxyCodeLine{[.]\ .}
\DoxyCodeLine{I1(Custo):\ 3\ |\ I2(Tempo(ms)):\ 15\ |\ I3(Iterações):\ 0\ |\ I4(Expansões):\ 10\ |\ I5(Gerações):\ 20\ |}
\DoxyCodeLine{I6(Lower\ Bound):\ 0}
\DoxyCodeLine{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_}

\end{DoxyCode}


Podemos observar que o algoritmo encontrou a solução de comprimento 3, a solução ótima. Fez várias iterações que não serviram para nada, antes de executar na iteração 4 com limite a 4. Mas essas árvores de procura são muito mais pequenas, pelo que o peso de executar essas procuras extra não é muito relevante.

As iterações que não serviram para nada, é na verdade uma afimrmação pouco precisa. Serviram para saber que não há solução nesse nível. Apenas assim é que se pode concluir na iteração 4 que a solução é óptima. Executando a procura em profundidade com limite 4, obtinhamos a solução ótima, mas sem saber que é ótima.

Podemos ver também a versão compactada da árvore de procura, contendo apenas informação do estado, tal como na procura em largura, mas desta vez com informação de onde o estado veio. Pela observação da árvore é possível verificar que a maior parte das ramificações são de dois sucessores, o que é natural dado que este problema tem apenas duas salas.

Vamos agora ver o que acontece se não limitarmos a procura em profundidade, colocando o limite=-\/1

\label{teste_aspirador2_aspirador-a14}%
\Hypertarget{teste_aspirador2_aspirador-a14}%
\hypertarget{teste_aspirador2_autotoc_md39}{}\doxysubsection{\texorpdfstring{Ação 14 -\/ Profundidade ilimitada}{Ação 14 - Profundidade ilimitada}}\label{teste_aspirador2_autotoc_md39}
Colocar a profundidade ilimitada (limite a -\/1), e o nível de debug a 1\+: {\bfseries{1; 2; 3; 7; -\/1; 2; 1; {\itshape ENTER}; 6.}}


\begin{DoxyCode}{0}
\DoxyCodeLine{Opção:\ 5}
\DoxyCodeLine{\#\#\#\#\#\#\#\#}

\end{DoxyCode}


Temos um crash do programa, e bem cedo. Como a procura em profundidade está implementada de forma recursiva, houve um problema no stack. Se tivesse implementada com listas, teríamos um problema de memória, como na procura em largura. Entrou-\/se num ramo infinito, mesmo neste pequeno problema, como aliás é possível imaginar após conhecermos a solução da procura com nível 10.

\label{teste_aspirador2_aspirador-a15}%
\Hypertarget{teste_aspirador2_aspirador-a15}%
\hypertarget{teste_aspirador2_autotoc_md40}{}\doxysubsection{\texorpdfstring{Ação 15 -\/ Desafio Procura Profundidade}{Ação 15 - Desafio Procura Profundidade}}\label{teste_aspirador2_autotoc_md40}
Lembra-\/se de algo dado na procura em largura, que impede ciclos infinitos e poderia permitir o uso da procura em profundidade ilimitada?



{\bfseries{Resposta}}\begin{adjustwidth}{1em}{0em}
Sim, não ignorar os estados repetidos não servem apenas para reduzir a árvore de procura. Evitam também ciclos infinitos. Com repetidos nos ascendentes ou gerados, consegue resolver com a procura em profundidade ilimitada, qualquer uma das 50 instâncias. \end{adjustwidth}


Está terminado esta execução de exemplo. Este problema tem uma heurística perfeita, pelo que, qualquer algoritmo informado encontra a solução ótima sem nunca se enganar. Iremos em outros problemas testar os algoritmos informados.

O custo de cada ação é sempre unitário, pelo que, o custo uniforme será mostrado num problema em que cada ação possa ter custo variável. As configurações e os testes empíricos, com as opções 7 e 8 do menu, são exemplificadas em outros problemas.

\texorpdfstring{$\vert$}{|} \href{teste_tvector.html}{\texttt{ Teste\+TVector}} \texorpdfstring{$\vert$}{|} \href{teste_aspirador1.html}{\texttt{ Aspirador 1}} \texorpdfstring{$\vert$}{|} \href{teste_aspirador2.html}{\texttt{ Aspirador 2}} \texorpdfstring{$\vert$}{|} \href{teste_puzzle8.html}{\texttt{ Puzzle 8}} \texorpdfstring{$\vert$}{|} \href{teste_8damas.html}{\texttt{ 8 Damas}} \texorpdfstring{$\vert$}{|} \href{teste_particao.html}{\texttt{ Partição}} \texorpdfstring{$\vert$}{|} \href{teste_artificial.html}{\texttt{ Artificial}} \texorpdfstring{$\vert$}{|} 